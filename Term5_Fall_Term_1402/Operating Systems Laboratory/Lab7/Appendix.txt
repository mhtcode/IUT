# Dynamic Allocation of Major Numbers

Some major device numbers are statically assigned to the most common devices. A list of those devices can be found in Documentation/devices.txt within the kernel source tree. The chances of a static number having already been assigned for the use of your new driver are small, however, and new numbers are not being assigned. So, as a driver writer, you have a choice: you can simply pick a number that appears to be unused, or you can allocate major numbers in a dynamic manner. Picking a num- ber may work as long as the only user of your driver is you; once your driver is more widely deployed, a randomly picked major number will lead to conflicts and trouble.

Thus, for new drivers, we strongly suggest that you use dynamic allocation to obtain your major device number, rather than choosing a number randomly from the ones that are currently free. In other words, your drivers should almost certainly be using alloc_chrdev_region rather than register_chrdev_region.

The disadvantage of dynamic assignment is that you can’t create the device nodes in advance, because the major number assigned to your module will vary. For normal use of the driver, this is hardly a problem, because once the number has been assigned, you can read it from /proc/devices.*

To load a driver using a dynamic major number, therefore, the invocation of insmod can be replaced by a simple script that, after calling insmod, reads /proc/devices in order to create the special file(s).

================================================================================

File Operations

So far, we have reserved some device numbers for our use, but we have not yet connected any of our driver’s operations to those numbers. The file_operations structure is how a char driver sets up this connection. The structure, defined in `<linux/fs.h>`, is a collection of function pointers. Each open file (represented internally by a file structure, which we will examine shortly) is associated with its own set of functions (by including a field called f_op that points to a file_operations structure). The operations are mostly in charge of implementing the system calls and are therefore, named open, read, and so on. We can consider the file to be an “object” and the functions operating on it to be its “methods,” using object-oriented programming terminology to denote actions declared by an object to act on itself. This is the first sign of object-oriented programming we see in the Linux kernel, and we’ll see more in later chapters.

Conventionally, a *file_operations* structure or a pointer to one is called fops (or some variation thereof). Each field in the structure must point to the function in the driver that implements a specific operation, or be left NULL for unsupported operations. The exact behavior of the kernel when a NULL pointer is specified is different for each function, as the list later in this section shows.

The following list introduces all the operations that an application can invoke on a device. We’ve tried to keep the list brief so it can be used as a reference, merely summarizing each operation and the default kernel behavior when a NULL pointer is used.

As you read through the list of file_operations methods, you will note that a number of parameters include the string `__user`. This annotation is a form of documentation, noting that a pointer is a user-space address that cannot be directly dereferenced. For normal compilation, __user has no effect, but it can be used by external checking software to find misuse of user-space addresses.

The rest of the chapter, after describing some other important data structures, explains the role of the most important operations and offers hints, caveats, and real code examples. We defer discussion of the more complex operations to later chapters, because we aren’t ready to dig into topics such as memory management, blocking operations, and asynchronous notification quite yet.


`struct module *owner`
	The first file_operations field is not an operation at all; it is a pointer to the module that “owns” the structure. This field is used to prevent the module from being unloaded while its operations are in use. Almost all the time, it is simply initialized to `THIS_MODULE`, a macro defined in `<linux/module.h>`.

`loff_t (llseek) (struct file , loff_t, int);`
	The `llseek` method is used to change the current read/write position in a file, and the new position is returned as a (positive) return value. The `loff_t` parameter is a “long offset” and is at least 64 bits wide even on 32-bit platforms. Errors are signaled by a negative return value. If this function pointer is NULL, seek calls will modify the position counter in the file structure (described in the section “The file Structure”) in potentially unpredictable ways.

`ssize_t (read) (struct file , char __user , size_t, loff_t );`
	Used to retrieve data from the device. A null pointer in this position causes the read system call to fail with -EINVAL (“Invalid argument”). A nonnegative return value represents the number of bytes successfully read (the return value is a “signed size” type, usually the native integer type for the target platform).

`ssize_t (aio_read)(struct kiocb , char __user *, size_t, loff_t);` 
	Initiates an asynchronous read—a read operation that might not complete before the function returns. If this method is NULL, all operations will be processed (synchronously) by read instead.

`ssize_t (write) (struct file , const char __user , size_t, loff_t );`
	Sends data to the device. If NULL, -EINVAL is returned to the program calling the write system call. The return value, if nonnegative, represents the number of bytes successfully written.

`ssize_t (aio_write)(struct kiocb , const char __user , size_t, loff_t );` 
	Initiates an asynchronous write operation on the device.

`int (readdir) (struct file , void *, filldir_t);` 
	This field should be NULL for device files; it is used for reading directories and is useful only for filesystems.

`unsigned int (poll) (struct file , struct poll_table_struct *);` 
	The poll method is the back end of three system calls: poll, epoll, and select, all of which are used to query whether a read or write to one or more file descriptors would block. The poll method should return a bit mask indicating whether non- blocking reads or writes are possible, and, possibly, provide the kernel with information that can be used to put the calling process to sleep until I/O becomes possible. If a driver leaves its poll method NULL, the device is assumed to be both readable and writable without blocking.

`int (ioctl) (struct inode , struct file *, unsigned int, unsigned long);`
	The ioctl system call offers a way to issue device-specific commands (such as for- matting a track of a floppy disk, which is neither reading nor writing). Addition- ally, a few ioctl commands are recognized by the kernel without referring to the fops table. If the device doesn’t provide an ioctl method, the system call returns an error for any request that isn’t predefined (-ENOTTY, “No such ioctl for device”).

`int (mmap) (struct file , struct vm_area_struct *);`
	mmap is used to request a mapping of device memory to a process’s address space. If this method is NULL, the mmap system call returns -ENODEV.

`int (open) (struct inode , struct file *);`
	Though this is always the first operation performed on the device file, the driver is not required to declare a corresponding method. If this entry is NULL, opening the device always succeeds, but your driver isn’t notified.

`int (flush) (struct file );`
	The flush operation is invoked when a process closes its copy of a file descriptor for a device; it should execute (and wait for) any outstanding operations on the device. This must not be confused with the fsync operation requested by user programs. Currently, flush is used in very few drivers; the SCSI tape driver uses it, for example, to ensure that all data written makes it to the tape before the device is closed. If flush is NULL, the kernel simply ignores the user application request.

`int (release) (struct inode , struct file *);  `
	This operation is invoked when the file structure is being released. Like open, release can be NULL.*

`int (fsync) (struct file , struct dentry *, int);`
	This method is the back end of the fsync system call, which a user calls to flush any pending data. If this pointer is NULL, the system call returns -EINVAL.

`int (aio_fsync)(struct kiocb , int);`
	This is the asynchronous version of the fsync method.

`int (fasync) (int, struct file , int);  `
	This operation is used to notify the device of a change in its FASYNC flag. Asyn- chronous notification is an advanced topic and is described in Chapter 6. The field can be NULL if the driver doesn’t support asynchronous notification.

`int (lock) (struct file , int, struct file_lock *);`
	The lock method is used to implement file locking; locking is an indispensable feature for regular files but is almost never implemented by device drivers.

`ssize_t (readv) (struct file , const struct iovec , unsigned long, loff_t ); ssize_t (writev) (struct file , const struct iovec , unsigned long, loff_t ); `
	These methods implement scatter/gather read and write operations. Applications occasionally need to do a single read or write operation involving multiple memory areas; these system calls allow them to do so without forcing extra copy operations on the data. If these function pointers are left NULL, the read and write methods are called (perhaps more than once) instead.

`ssize_t (sendfile)(struct file , loff_t , size_t, read_actor_t, void );`
	This method implements the read side of the sendfile system call, which moves the data from one file descriptor to another with a minimum of copying. It is used, for example, by a web server that needs to send the contents of a file out a network connection. Device drivers usually leave sendfile NULL.

`ssize_t (sendpage) (struct file , struct page , int, size_t, loff_t , int);`
	sendpage is the other half of sendfile; it is called by the kernel to send data, one page at a time, to the corresponding file. Device drivers do not usually implement sendpage.

`unsigned long (get_unmapped_area)(struct file , unsigned long, unsigned long, unsigned long, unsigned long);`
	The purpose of this method is to find a suitable location in the process’s address space to map in a memory segment on the underlying device. This task is normally performed by the memory management code; this method exists to allow drivers to enforce any alignment requirements a particular device may have. Most drivers can leave this method NULL.

`int (*check_flags)(int)`
	This method allows a module to check the flags passed to an fcntl(F_SETFL...) call.

``int (dir_notify)(struct file , unsigned long);``
	This method is invoked when an application uses fcntl to request directory change notifications. It is useful only to filesystems; drivers need not implement dir_notify.

================================================================================

struct file_operations scull_fops = {

.owner = THIS_MODULE,
.llseek = scull_llseek,
.read = scull_read,
.write = scull_write,
.ioctl = scull_ioctl,
.open = scull_open,
.release =  scull_release,
};

================================================================================

# The file Structure

struct file, defined in `<linux/fs.h>`, is the second most important data structure used in device drivers. Note that a file has nothing to do with the FILE pointers of user-space programs. A FILE is defined in the C library and never appears in kernel code. A struct file, on the other hand, is a kernel structure that never appears in user programs.

The file structure represents an open file. (It is not specific to device drivers; every open file in the system has an associated struct file in kernel space.) It is created by the kernel on open and is passed to any function that operates on the file, until the last close. After all instances of the file are closed, the kernel releases the data structure.

In the kernel sources, a pointer to struct file is usually called either file or `filp` (“file pointer”). We’ll consistently call the pointer `filp` to prevent ambiguities with the structure itself. Thus, file refers to the structure and `filp` to a pointer to the structure.

The most important fields of struct file are shown here. As in the previous section, the list can be skipped on a first reading. However, later in this chapter, when we face some real C code, we’ll discuss the fields in more detail.

# The inode Structure

The `inode` structure is used by the kernel internally to represent files. Therefore, it is different from the file structure that represents an open file descriptor. There can be numerous file structures representing multiple open descriptors on a single file, but they all point to a single `inode` structure.

The `inode` structure contains a great deal of information about the file. As a general rule, only two fields of this structure are of interest for writing driver code:

`dev_t i_rdev`:
	For `inodes` that represent device files, this field contains the actual device number.

`struct cdev *i_cdev`:
	struct `cdev` is the kernel’s internal structure that represents char devices; this field contains a pointer to that structure when the `inode` refers to a char device file.

The type of `i_rdev` changed over the course of the 2.5 development series, breaking a lot of drivers. As a way of encouraging more portable programming, the kernel developers have added two macros that can be used to obtain the major and minor number from an `inode`:

     unsigned int iminor(struct inode *inode);
     unsigned int imajor(struct inode *inode);

In the interest of not being caught by the next change, these macros should be used instead of manipulating `i_rdev` directly.

================================================================================

The inode Structure

The `inode` structure is used by the kernel internally to represent files. Therefore, it is different from the file structure that represents an open file descriptor. There can be numerous file structures representing multiple open descriptors on a single file, but they all point to a single `inode` structure.

The `inode` structure contains a great deal of information about the file. As a general rule, only two fields of this structure are of interest for writing driver code:

`dev_t i_rdev`:
	For `inodes` that represent device files, this field contains the actual device number.

`struct cdev *i_cdev`:
	struct `cdev` is the kernel’s internal structure that represents char devices; this field contains a pointer to that structure when the `inode` refers to a char device file.

The type of `i_rdev` changed over the course of the 2.5 development series, breaking a lot of drivers. As a way of encouraging more portable programming, the kernel developers have added two macros that can be used to obtain the major and minor number from an `inode`:

     unsigned int iminor(struct inode *inode);
     unsigned int imajor(struct inode *inode);

In the interest of not being caught by the next change, these macros should be used instead of manipulating `i_rdev` directly.

================================================================================

